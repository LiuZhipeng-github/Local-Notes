# 运输层

## 一、概述
> > 1.运输层功能
> >
> > - 运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）
> > - 运输层还要对收到的报文进行差错检测
> > - 运输层需要有两种不同的运输协议，即面向连接的 **TCP** 和无连接的 **UDP**
> >
> > 2.运输层的两个主要协议
> > TCP/IP 的运输层有两个不同的协议：
> >
> > - **用户数据报协议 UDP**(User Datagram Protocol)
> > - **传输控制协议 TCP**(Transmission Control Protocol)
> >
> > UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。
> >
> > TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。
> >
> > TCP和UDP最基本的责任是：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机交付扩展到进程间交付被称为运输层的多路复用与多路分解。
>
> ## 二、多路复用与多路分解
>
> > 1.多路复用与多路多路分解
> >
> > **主机将一个到达运输层报文段定向到适当套接字的过程**：每个运输层报文段中具有几个字段，在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。**在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(用于以后分解)从而生成报文段，然后将这些报文段传递到网络层，这些工作叫多路复用**，**将运输报文段中的数据交付到正确的套接字的工作称为多路分解**
> >
> > 2.面向无连接的多路复用与多路分解
> >
> > 在运输层，无连接的网络传输是通过UDP来实现的。UDP报文中只有源端口号和目的端口号，一个UDP套接字是由一个含有目的IP地址和目的端口号的二元组来全面标识的。在客户端，源端口号是客户进程套接字的端口号，目的端口号是服务器的端口号。而在服务器端，源端口号是服务器的创建的套接字的端口号，而目的端口号是客户端的套接字的端口号。
> >
> > 注意：我们看到使用UDP来传输报文段时，一个UDP套接字是由一个含有目的IP地址和目的端口号的二元组来全面标识的。因此，如果两个UDP报文段有不同的源IP地址和源端口，但具有相同的IP地址和目的端口号，那么这两个报文段将通过相同的目的端口号定向到相同的目的进程。
> >
> > 3.面向连接的多路复用与多路分解
> >
> > 网络上主机间的进程间通信，实质上是通过套接字来实现的。在运输层中面向连接的网络传输多使用TCP，而TCP套接字和UDP套接字之间有一个细微的差别，就是，TCP套接字是由一个四元组（源IP地址、源端口号，目的IP地址，目的端口号）来标识的。这样，当一个TCP报文段从网络到达一台主机时，主机会使用全部4个值来将报文段定向，即多路分解到相应的套接字。
> >
> > 注意：与UDP不同的是，两个具有不同源IP或源端口号的TCP报文段将被重定向到两个不同的套接字。对于一个TCP服务器，当它接受一个连接时，它会产生一个新的套接字，然后通过新的套接字来与客户端通信，也就是通过新的套接字来把数据发送回给客户端。由于每一个连接都会产生一个新的套接字，所以具有不同的源IP或源端口号的连接就是一个不同的连接，对应着产生的新的不同的套接字。
>
> ## 三、UDP（面向无连接）
>
> > 1.UDP的主要特点：
> >
> > - **UDP 是无连接的**，即发送数据之前不需要建立连接。
> > - **UDP 使用尽最大努力交付**，即不保证可靠交付，同时也不使用拥塞控制
> > - **UDP 是面向报文的**
> > - **UDP 没有拥塞控制**，很适合多媒体通信的要求。
> > - **UDP 支持一对一、一对多、多对一和多对多的交互通信**
> > - **UDP 的首部开销小**，只有 8 个字节

> > 2.UDP提供不可靠服务时，具有TCP所没有的优势：
> >
> > * UDP无连接且分组首部开销小，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。UDP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。
> >
> > * UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。
> >
> >   注意：如果每个人都启动流式高比特率视频而不使用任何拥塞控制的话，就会使路由器中有大量的分组溢出，伴随着拥塞，TCP的发送速率也会被降低。UDP中缺乏拥塞控制能够导致UDP发送方和接收方之间的高丢包率，并挤跨TCP会话
> >
> > * UDP是面向报文的，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。
> >
> > 3.UDP报文结构
> >
> > ![UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，
> > 1.**源端口**： 源端口号，需要对方回信时选用，不需要时全部置0.
> > 2.**目的端口**：目的端口号，在终点交付报文的时候需要用到。
> > 3.**长度**：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）
> > 4.**校验和**：检测UDP数据报在传输中是否有错，有错则丢弃。
> > 该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0.
> > 当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。
> > 如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。](https://img-blog.csdnimg.cn/20181226160325166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FhMTkyODk5Mjc3Mg==,size_16,color_FFFFFF,t_70)
> >
> > UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，
> > 1.**源端口**： 源端口号，需要对方回信时选用，不需要时全部置0.
> > 2.**目的端口**：目的端口号，在终点交付报文的时候需要用到。
> > 3.**长度**：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）
> > 4.**校验和**：检测UDP数据报在传输中是否有错，有错则丢弃。如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。（发送方的UDP对报文段中所有的16比特字的和进行反码运算，求和时遇到任何溢出都回卷。在接收方将收到的所有比特字加在一起，这里包括检验和，如果该分组中没有引入差错，则接收方的该和应当全是1，如果出现0说明该分组出现差错）#####
>
> ## 四、可靠数据传输
>
> >1.构造可靠的传输协议
> >
> >> 1.经完全可靠的信道的可靠数据传输：rdt1.0
> >>
> >> * 不会发生错误
> >> * 不会丢弃分组
> >>
> >> 主要有传输端与接收端两个部分，资料传输方式很单纯，传输端等待上层传资料进来，收到上面的资料以后装成封包送出去。接收端收到封包以后，将封包解开，把讯息往上送。
> >>
> >> Rdt1.0的缺陷：
> >>
> >> * 利用校验和检测位错误
> >>
> >> Rdt1.0改进（应对错误）：
> >>
> >> * ACK：接收方显式的告知发送分组已经正确接收
> >> * NAK：接收方显式的告知发送方分组有错
> >> * 发送方收到NAK后，重传分组
> >
> >2.经具有比特差错信道的可靠数据传输：rdt2.0
> >
> >> * 差错检测
> >> * 接收方反馈控制信息：ACK/NAK
> >> * 重传
> >>
> >> 基于这样的重传机制的可靠数据传输协议称为自动重传请求协议（ARQ）
> >>
> >> 当发送方处于等待ACK或NAK的状态时，他不能从上层获取更多的数据。这就是说，rdt_send（）事件不可能出现；仅当接收到ACK并离开该状态时才能发生这样的事件，因此，发送方将不会发送一块新数据，除非发送方确信接收方已经正确接收当前分组。由于这种行为，rdt2.0被称为停等协议
> >>
> >> 
> >
> >3.rdt2.1
> >
> >> 解决重复分组与ACK/NAK消息发生错误的问题
> >>
> >> 但是rdt 2.0没有考虑到ACK或NAK分组受损的可能性，解决这个问题的方法(几乎所有现有的数据传输协议中，包括TCP都采用)是在数据分组中添加一个新字段，让发送方对其数据分组编号，即将发送数据分组的**序号**放在该字段，于是接收方只需要检查序号即可确定收到的分组是否需要一次重传。当接收到失序分组时，接收方对所接受的分组发送一个肯定确认。如果收到受损分组，则接收方将发送一个否定确认。如果不发送NAK，而是对上次正确接收的分组发送一个ACK（即接收到冗余ACK）后，就知道没有正确接收到跟在被确认两次的分组后的分组。
> >>
> >> 4、rdt2.2
> >> rdt2.2是在rdt2.1上的基础之上做了小小的改善，摒弃了NAK，只需采用ACK。我们在ACK的信息上加上了期望的顺序号，现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回（ACK，1），发送方接着发送1号数据包。如果接收方接收到0号数据包出现错误，返回（ACK，0），发送方重传0号数据包。
> >
> >5.经具有比特差错的丢包信道的可靠数据传输：rdt3.0
> >
> >> 3.0同时考虑到封包遗失与资料错误的情形，除了使用ACK机制，另外在传送端多了倒数计时器，封包送出去如果超过时间仍未收到ACK或是收到不正确编号的ACK，则再送出封包一次。
> >>
> >> 缺陷：rdt3.0是一个功能正确的协议，但是它的性能却很差，rdt3.0的性能问题的核心在于它是一个停等协议。
> >>
> >> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200815092703805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0MTA5NA==,size_16,color_FFFFFF,t_70#pic_center)
> >
> >6.流水线可靠传输数据协议
> >
> >> 在今天的高速网络中，rdt 3.0性能问题的核心在于它是一个停等协议，受到这个机制本身的影响，需要更好的传输协议。流水线技术是解决这种特殊性能问题的一个非常简单的方法：不使用停等方式运行，允许发送端发送多个分组而无需等待确认。
> >>
> >> 虽然流水线可以直线提升 rdt 3.0 协议的性能，但是也会带来如下的影响：
> >>
> >> - 必须增加序号的范围。因为每个传输中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中尚未确认的分组
> >> - 协议的发送端和接收端也必须缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组，接收方或许也需要缓存那些已正确接收的分组
> >> - 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏和延时过大的分组。
> >>
> >> 解决流水线的差错恢复有两种基本方法，分别为 **回退 N 步（Go-Back-N, GBN）** 和 **选择重传（Selective Repeat, SR）**。
> >>
> >> GBN协议
> >>
> >> 传输多个封包 必须有个暂存的区域，暂存的区域中存在着窗格大小(Window Size) N，存放着各种封包(已确认、已送出但未收到ACK、未送出的封包等等)。接收端也会开启窗格来接收封包，会记着目前收到封包的编号，假设收到顺序不对的封包N+1(等待接收第N个，下一个传来的却是第N+1号)，会将N以后的封包全部丢弃，此时传送端一直没收到ACK(N)，会把N号以后的封包全部重新传送出去。
> >>
> >> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200815101708330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0MTA5NA==,size_16,color_FFFFFF,t_70#pic_center)
> >>
> >> ![img](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2358821438,1240211363&fm=15&gp=0.jpg)
> >>
> >> SR协议
> >>
> >> GBN的传送方法往往会造成不必要的重复，因此SR的传送方法就是只针对未收到的封包做重新传输的动作。首先规划出大小为N的窗格来限制大小，窗格的基底会停留在最近一个尚未收到ACK的封包区域，当封包时间逾时会重新送出封包，直到收到该封包的ACK 窗格基底才会往前移动。（不采用累计确认，接收端维护一个缓存）
> >>
> >> 
> >>
> >> ![img](https://img-blog.csdn.net/20131221210033265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHBwcmluY2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
> ## 五、TCP
>
> >### 1、TCP连接
> >
> >面向连接的、可靠的字节流服务，仅有两方进行彼此通信.客户进程通过套接字传递数据，TCP将这些数据引导到该连接的发送缓存里，发送缓存是发起三次握手的期间设置的缓存之一。TCP可从缓存中取出并放入报文段中的数据受限于最大报文段长度（MSS），即由本地发送主机发送的最大链路层帧长度来设置。
> >
> >### 2.TCP报文结构
> >
> >![Alt text](%E8%BF%90%E8%BE%93%E5%B1%82.assets/70-20201121211604871.png)
> >
> >源端口、目标端口：计算机上的进程要和其他进程通信是要通过计算机端口的，而一个计算机端口某个时刻只能被一个进程占用，所以通过指定源端口和目标端口，就可以知道是哪两个进程需要通信。源端口、目标端口是用16位表示的，可推算计算机的端口个数为2^16个。

> >序列号：序号范围是0~2^32-1。TCP是面向字节流的，TCP连接中传送的字节流中的每个字节都按顺序编号。整个要传送的字节流的起始序号必须要在连接建立时设置。首部中的序号字段值指的是本报文段所发送的数据的第一个字节的序号。

> >确认号：表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。

> >TCP首部长度：由于TCP首部包含一个长度可变的选项部分，所以需要这么一个值来指定这个TCP报文段到底有多长。该字段的单位是32位字，即：4个字节。

> >URG：表示本报文段中发送的数据是否包含紧急数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当URG=1时才有效。

> >ACK：表示是否前面的确认号字段是否有效。ACK=1，表示有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1。

> >PSH：告诉对方收到该报文段后是否应该立即把数据推送给上层。如果为1，则表示对方应当立即把数据提交给上层，而不是缓存起来。

> >RST：只有当RST=1时才有用。如果你收到一个RST=1的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说明你上次发送给主机的数据有问题，主机拒绝响应。

> >SYN：在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1。

> >FIN：标记数据是否发送完毕。如果FIN=1，就相当于告诉对方：“我的数据已经发送完毕，你可以释放连接了”

> >接收窗口大小：窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）。窗口值作为接收方让发送方设置其发送窗口的依据。并且窗口值是经常在动态变化着。

> >校验和：检验和：2字节。检验范围包括首部和数据两部分。和UDP用户数据报一样，在计算校验和 时，要在TCP报文段加上12字节的伪首部。

> >紧急指针：标记紧急数据在数据字段中的位置。

> >选项部分：长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。
> >
> >### 3.TCP的超时重传
> >
> >1.估计往返时间（指数加权移动平均）
> >报文段的样本RTT（表示为SampleRTT）为某报文段**发出**到对该报文段的**确认被收到**之间的时间量大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而不是为每个报文段测量一个SampleRTT。也就是说，在任何时刻，仅为一个已发送但是目前尚未被确认的报文段估计SampleRTT,从而产生一个接近每个RTT的新SampleRTT值。
> >另外，TCP绝不为被重传的报文计算SampleRTT；它仅为传输一次的报文段测量SampleRTT。>>由于路由器的拥塞和端系统负载的变化，这些报文段的SampleRTT是波动的，所以给定的任何
> >SampleRTT都是非典型的。因此要取得典型的RTT，就要对SampleRTT进行加权取值。
> >			EstimatedRTT（SampleRTT的均值） = (1-α)*EstimatedRTT + α*SampleRTT  α参考值为> >0.125
> >
> >2.设置间隔（利用RTT偏差纠正超时间隔）
> >估算SampleRTT偏离EstimatedRTT的程度：
> >				DevRTT = (1-β)*DevRTT + β*|SampleRTT - EstimatedRTT|   β参考值为0.25
> >	超时时间间隔应该大于EstimatedRTT并且不能大于太多。超时时间间隔为EstimatedRTT加上> >  >一些余量。**并且在SampleRTT值波动大时，余量较大；当波动较小时，余量较小**。因此就>  >用到了DevRTT。由此得出TCP重传时间间隔计算公式
> >							TimeoutInterval = EstimatedRTT + 4*DevRTT
> >
> >3.保活定时器（keepalive timer）
> >
> >当一个连接长时间闲置时，保活定时器会超时而使一方去检测另一方是否仍然存在。如果未得到响应，就终止该连接。
> >
> >4.持续定时器( Persistence timer) 
> >
> >持续定时器用于防止出现以下死锁情况：如果接收方主机发生了缓冲上溢情况，就会发送一个窗口为 0 的应答，通知发送方等待。发送主机收到后就会中止发送,等待接收方窗口为非 0 的确认,才会重新开始发送。
> >
> >如果接收方主机发出的修正窗口分组丢失了，发送方和接收方都会等待对方的进一步动作，这就出现了死锁的情况。当发送方收到窗口为 0 的应答时，等待并启动持续定时器，当持续定时器超时，发送方就向接收方发送一探测数据段。接收方应答中应包含窗口大小。如果窗口仍为 0，则重新设置持续定时器。如果查询仍不能得到窗口大小，TCP 协议会重新设置连接。
> >
> >5.TCP 连接的定时器
> >
> >用于每个 TCP 连接的定时器是用在断开连接操作中的 TIME WAIT 状态，设置为分组最长生命期的两倍，以确保当一个连接断开后，由它创建的分组完全消失。
> >
> >### 4.可靠数据传输
> >
> >可靠数据传输
> >1.超时加倍
> >TCP重传具有最小序号的还未被确认的报文段。只是每次TCP重传时都会将下一次的超时间隔设为先前的两倍，而不是从EstimatedRTT和DevRTT推算出的值。
> >假设当前超时重传定时器溢出时，与最早的未被确认的报文段相关联的RTO为0.75s，TCP就会重传报文段，并版新的RTO设置为1.5s，如果1.5s后又溢出了，则TCP将再次重传报文段，并把RTO设置为3秒。因此，超时间隔在每次重传后会呈指数上升，然而每当重传定时器在另外两个事件（收到上层应用的数据和收到ACK）中的任意一个启动时，RTO有最近的EstimatedRTT 和DevRTT重新计算。
> >2.快速重传
> >要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
> >快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。
> >3.累计确认
> >TCP确认信息是基于序列号累积的。每次当设备A发送片段给设备B，设备B查看该片段的确认号字段。所有低于该字段的序列号都已经被设备A接收了。因此，当片段中所发送的所有字节的序列号都比设备A到设备B的最后一个确认号小的时候，一个从设备B发到设备A的片段被认为是确认了。
> >4.TCP选择重传
> >许多TCP实现会将正确接收但失序的报文段缓存起来，TCP将至多重传一个丢失的报文段。
> >
> >![快速重传：在某报文段的超时重传定时器溢出前重传丢失报文段](https://img-blog.csdn.net/20180710142127806?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doZ3RoZW9uZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
> >
> >
> >3.流量控制
> >
> >TCP为他的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。TCP通过让发送方维护一个接受窗口的变量来提供流量控制，接收窗口用于给对方发一个指示—该接收方还有多少可用的缓存空间。因为TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。
> >
> >对于发送端的数据缓冲区有这些量：LastByteSent是目前发送的最后1比特的数据编号；LastByteAckd是目前接收到确认的最后1比特的数据编号；Revwin是窗口大小。鉴于每次发送方都是收到ACK之后滑动窗口继续发送，发送到LastByteSent这个位置，LastByteSent-LastByteAckd也就是这次发送数据的多少，那么只要满足：LastByteSent–LastByteAckd<=RcvWin(接收端空闲窗口大小) 就会保证不会溢出了。
> >
> >
> >
> >![这里写图片描述](https://img-blog.csdn.net/20180620002859330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
> >
> >### 5.三次握手
> >
> >![Alt text](https://img-blog.csdn.net/20180620002440131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
> >
> >
> >
> >1, TCP服务器进程先创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 此时服务器就进入了 LISTEN（监听）状态
> >2, TCP客户端进程也是先创建传输控制块TCB, 然后向服务器发出连接请求报文，此时报文首部中的同步标志位SYN=1, 同时选择一个初始序列号 seq = x, 此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定, SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
> >3, TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的 ACK=1, SYN=1, 确认序号是 x+1, 同时也要为自己初始化一个序列号 seq = y, 此时, TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据, 但是同样要消耗一个序号。
> >4, TCP客户端进程收到确认后还, 要向服务器给出确认。确认报文的ACK=1，确认序号是 y+1，自己的序列号是 x+1.
> >5, 此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。
> >
> >![Alt text](https://img-blog.csdn.net/20180620002506635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
> >
> >### 6.四次挥手
> >
> >1, 客户端进程发出连接释放报文，并且停止发送数据。
> >释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
> >2, 服务器收到连接释放报文，发出确认报文，ACK=1，确认序号为 u+1，并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）状态。
> >TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
> >3, 客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最终数据）
> >4, 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
> >5, 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认序号为w+1，而自己的序列号是u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
> >6, 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
> >
> >### 7.拥塞控制原理
> >
> >TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量组成。运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口，它对一个TCP发送方能向网络中发送流量的速率进行了限制。拥塞窗口代表着一个TCP允许发送的最大数据量。
> >拥塞控制策略：1.一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。2.一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的效率。3.带宽探测：为探测拥塞开始出现的速率，TCP增加他的传输速率，从该速率后退，进而再次探测，看看拥塞开始速率是否发生了变化。
> >注意：如果确认已相当慢的速率到达，则该拥塞窗口将以相当慢的速率增加。另方面，如果确认以高速率到达，则该拥塞窗口将会更为迅速的增大。
> >TCP拥塞控制算法：
> >1.慢启动
> >
> >慢启动是TCP的一个拥塞控制机制，慢启动算法的基本思想是当TCP开始在一个网络中传输数据或发现数据丢失并开始重发时，首先慢慢的对网路实际容量进行试探，避免由于发送了过量的数据而导致阻塞。
> >　　慢启动为发送方的TCP增加了另一个窗口：拥塞窗口(congestion window)，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为 1个报文段（即另一端通告的报文段大小）。每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。发送方开始时发送一个报文段，然后等待 ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的 A C K时，拥塞窗口就增加为4。这是一种指数增加的关系。
> >
> >2.拥塞避免
> >
> >网络中拥塞的发生会导致数据分组丢失，需要尽量避免。在实际中，拥塞算法与慢启动通常在一起实现，其基本过程：
> >
> >   　　 1. 对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节。
> >     　　 2. TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小。拥塞避免是发送方使用 的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估 计，而后者则与接收方在该连接上的可用缓存大小有关。
> >     　　 3. 当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd 和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则 cwnd被设置为1个报文段（这就是慢启动）。
> >       　　 4. 当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正 在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到回到当拥塞发生时所处位置的半时候才停止（因为记录了在步骤2 中制造麻烦的窗口大小的一半），然后转为执行拥塞避免。
> >
> >![img](https://img-blog.csdn.net/20180409200458572?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3MTA0NTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
> >
> >3.快速恢复
> >
> >快速重传以后，因为走的不是慢启动而是拥塞避免算法，所以这又叫做快速恢复算法。算法流程如下：
> >
> >1. 当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。设置cwnd为ssthresh加上3倍的报文段大小。
> >
> >2. 每次收到另一个重复的ACK时， cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。
> >
> >3. 当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个 ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段 的确认。
> >
> > ![这里写图片描述](https://img-blog.csdn.net/20180409203135153?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3MTA0NTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
> >
> > 加法增大：当网络频发出现超时情况时，ssthresh就下降的很快，为了减少注入到网络中的分组数，而加法增大是指执行拥塞避免算法后，是拥塞窗口缓慢的增大，以防止网络过早出现拥塞。
> > 乘法减小：无论在慢启动阶段还是在拥塞控制阶段，只要网络出现超时，就是将cwnd置为1，ssthresh置为cwnd的一半，然后执行慢启动（cwnd小于ssthresh）。
> >
> > ### 8.常见问题
> >
> > #### 三次握手为什么不用两次?
> >
> > 主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。
> > 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
> >
> > #### 为什么最后客户端还要等待 2*MSL的时间呢?
> >
> > MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
> >
> > 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
> >
> > 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
> >
> > #### 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
> >
> > 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
> > 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
> >
> > #### 如果已经建立了连接, 但是客户端突发故障了怎么办?
> >
> > TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
> >
> >#### 最大等待时延
> >
> >**tcp_syn_retries**：
> >    The  maximum number of times initial SYNs for an active TCP connection attempt will be retransmitted.  This value should not be higher than 255.  The default value  is 6, which corresponds to retrying for up to approximately 127 seconds.  Before Linux 3.7, the default value was 5, which (in conjunction with calculation based on other  kernel parameters) corresponded to approximately 180 seconds.
> >活动TCP连接尝试的初始SYN的最大次数将被重传。 此值不应大于255。默认值为6，这对应于重试最多约127秒。 在Linux 3.7之前，默认值为5（结合基于其他内核参数的计算）大约为180秒。
> >**tcp_synack_retries**:
> >   The  maximum number of times a SYN/ACK segment for a passive TCP connection will be retransmitted.  This number should not be higher than 255.
> >用于被动TCP连接的SYN / ACK段的最大传输次数。 此数字不应大于255。
> >**tcp_retries1**：
> >The number of times TCP will attempt to retransmit a  packet  on an  established connection normally, without the extra effort of getting the network layers involved.  Once we exceed this number of retransmits, we first have the network layer update the route if possible before each new retransmit.  The default is the  RFC specified minimum of 3.
> >TCP通常尝试在已建立的连接上重传一个包的次数，而不需要额外的努力使网络层参与。一旦重传次数超过这个数量，我们首先让网络层在每次重传之前尽可能**更新路由**。默认是RFC指定的最小值为3。
> >
> >**tcp_retries2**：
> >The  maximum  number  of  times  a TCP packet is retransmitted in established state  before giving up.  The default value is 15, which  corresponds  to  a  duration  of approximately  between  13  to 30 minutes, depending on the retransmission timeout.
> >
> >在放弃之前，TCP包在已建立的状态下被重新传输的最大次数。默认值是15，它对应的持续时间大约在13到30分钟之间，具体取决于重新传输超时。如果超出这个阈值，会直接放弃重 传，关闭TCP流
> >
> >#### nagle算法与延迟确认机制
> >
> >**1.nagle算法:** TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的 > >数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。 Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的> >ACK确认该数据已收到。TCP需要收集这些小数据，将其整合到一个报文段中发送。它迫使TCP遵循停等行为模式，因此TCP发送端只有在接收到全部ACK后才能继续发送。
> >
> >Nagle算法的规则：
> >（1）如果包长度达到MSS，则允许发送；
> >（2）如果该包含有FIN，则允许发送；
> >（3）设置了TCP_NODELAY选项，则允许发送；
> >（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
> >（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。
> >
> >**2. 延迟ACK：** 如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送 ack，如果在延迟ack定时器触发时候，发现ack尚未发送，则立即单独发送； 与Nagle算法一样，延迟ACK的目的也是为了减少网络中传输大量的小报文数，但该报文数是针对ACK报文的。 一个来自发送端的报文到达接收端，TCP会延迟ACK的发送，希望应用程序 会对刚刚收到的数据进行应答，这样就可以用新数据将ACK捎带过去。 注意：当有两个未确认的包需要确认时，立即发送ACK
> >
> >**3. 当Nagle遇上延迟ACK：** 试想如下典型操作，写-写-读，即通过多个写小片数据向对端发送单个逻辑的操作，两次写数据长度小于MSS，当第一次写数据到达对端后，对端延迟ack，不发送ack，而本端因为要发> >送的数据长度小于MSS，所以nagle算法起作用，数据并不会立即发送，而是等待对端发送的第一次数据确认ack；这样的情况下，需要等待对端超时发送ack，然后本段才能发送第二次> > >写的数据，从而造成延迟； https://blog.nowcoder.net/sigma711 ![输入图片说明](%E8%BF%90%E8%BE%93%E5%B1%82.assets/104057_a723c041_6583593.png)
> >
> >https://blog.nowcoder.net/sigma711  
> >
> >
> >
> >
> >
> >
> >
> >

