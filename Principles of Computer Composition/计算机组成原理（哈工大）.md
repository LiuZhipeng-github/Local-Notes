第1章 计算机系统概论

## 1.1 计算机系统简介

### 1.1.1概念

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70.png)

- 系统复杂性管理的方法
  - 抽象
    - 对过程或细节隐藏，以便把结构表达更清楚
  - 3`Y
    - 层次化：将被设计的系统划分为多个模块或子模块
    - 模块化：有明确定义的功能和接口
    - 规则性：模块更容易被重用
 - 计算机的软件部分划分成了 “应用软件” 与 “系统软件” ，“应用软件” 是无法访问 “硬件” 提供的接口的，除非通过系统软件这层介质才可以
### 1.1.2 计算机系统的层次结构

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM5OTc2,size_16,color_FFFFFF,t_70.png)

- 最早出现的语言只有机器语言（实际机器M1）
  - 0、1代码，缺点是编写难度大，操作过程容易出错
- 汇编语言，符号式代码(虚拟机器M2)
  - 但是没有机器能直接识别这种汇编程序
  - 翻译过程由机器系统软件中的汇编程序来完成
- 高级语言(虚拟机器M3)
  - 两种翻译方式：编译程序和解释程序
- 微指令程序(微程序机器M0)
  - M1向下延伸形成下一级的微程序机器M0，将机器语言的每一条机器指令翻译成一组微指令，即构成一个微程序
  - M0每执行完对应一条机器指令的一个微程序后，便由机器M1中的下一条机器指令使机器M0自动进入与其相对应的另一个微程序的执行。
  - 可见，M0是对实际机器M1的分解，即用M0的微程序解释并执行M1的每一条机器指令
  - 由于机器M0也是实际机器，为了区别于M1，将M1称为传统机器，将M0称为微程序机器
  - 这样又可以认为计算机系统具有四级层次结构
- 实际上在M1、M2中间还有一级虚拟机器，是操作系统软件构成的

```
graph TB
虚拟机器M4:用编译程序翻译成汇编语言程序 --> 虚拟机器M3:用汇编语言翻译成机器语言程序-->虚拟机器M2:用机器语言解释操作系统-->实际机器M1:用微指令解释机器指令-->微程序机器M0:由硬件直接执行微指令
```

- 计算机组成与计算机体系结构从研究内容上来说有什么区别？
- ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201207194347884.png)
  - 计算机系统结构：能够被程序员所见到的计算机系统的属性
    - 指令集
    - 数据类型
    - 存储器寻址技术
    - I/O机理等
    - 对于不同层次上编程的程序员，所看到的计算机属性也各不相同
  - 计算机组成：如何实现计算机体系结构所体现的属性
    - 包含了许多对程序员透明的硬件细节
    - 如：如何取指令、分析指令、取操作数、运算、送结果等，这些属于计算机组成问题
    - 但指令系统体现了机器属性，属于计算机结构问题
  - 一台机器**是否具备乘法指令的功能**，是一个结构问题
  - 乘法指令**采用什么方式**，是一个组成问题

## 1.2 计算机的基本组成

###  1.2.1 冯·诺依曼计算机的特点

- 以“存储程序”概念为基础的各类计算机通称冯·诺依曼机

  - 计算机由**五大部件**组成：
  - 运算器
  - 存储器
  - 控制器
  - 输入设备
  - 输出设备

- 指令和数据以**同等地位**存放在存储器内，并可按地址寻访

- 指令和数据均用**二进制数**表示

- 指令由**操作码**（操作性质）和**地址码**（操作数在存储器中的位置）组成

- 存储程序指令在存储器内按顺序存放。通常，指令是按顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序。

- 机器**以运算器为中心**，输入输出设备与存储器的数据传输通过运算器完成

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191003221946297.png)
  

在上文中也明确给讲到，冯诺依曼机器是以 “运算器” 为中心的计算机。设想数据从 “输入设备” 进入计算机之后，想要从计算机输出就必须要经过 “运算器”，这无疑让 “运算器” 变成了整个计算机中最忙的一个部件，这样一来运算器就变成了该硬件结构计算机的瓶颈。 所以要对该机型进行改进：改为以存储器为中心的机器。

### 1.2.2 计算机硬件框图

- 以运算器为中心
  - 运算器：完成算术运算和逻辑运算，中间结果暂存在运算器内
- 存储器：用来存放数据和程序
  - 控制器：用来控制、指挥程序和数据的输入、运行以及处理运算结果
  - 输入设备：常见的键盘、鼠标等。把人熟悉的信息形式转换为机器能识别的信息形式
  - 输出设备：打印机、显示器等。
- 以运算器为中心的机器缺点是，数据输入输出必须要经过运算器，运算器会成为计算机系统的瓶颈
- 对以运算器为中心的机器进行改进，改为以存储器为中心的计算机机器
  - –>控制线
  - ——>反馈线
  - ===》数据线

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83.png)

- 由于运算器（ALU）和控制器（CU）在逻辑关系和电路结构上联系十分紧密，通常合起来称为中央处理器（CPU）
- 把输入输出设备简称为I/O设备
- 存储器为又分主存和辅存（或称外存），主存储器存放程序和数据，可以直接与CPU交换信息
- 现代机器可以认为是三大部分组成：CPU、I/O设备以及主存储器

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191003221753149.png)

- ALU完成算术逻辑运算
- CU解释存储器中的指令，发出各种操作命令来执行指令
- I/O设备也受CU控制，用来完成输入、输出操作
- 计算机有条不紊地自动工作都是在**控制器统一指挥**下完成的

### 1.2.3 计算机的工作步骤

- 用计算机解决一个实际问题通常包含两大步骤

  - 上机前的各种准备
    1. 建立数学模型
    2. 确定计算方式
    3. 编制解题程序
  - 上机运行

- 设某机器的指令字长为16位，其中操作码占6位（在CU中操作），地址码占10位（CU在操作码之后要操作（存、取）的数据的地址）

  | 操作码 | 地址码 |
  |:------:|:------:|
  | 6位    | 10位   |

  | 操作码 | 操作性质 | 具体内容                                 |
  |:------:| :------: | :------:|
  | 000001 | 取数     | 存储单元中保存的数据保存到ACC中          |
  | 000010 | 存数     | ACC中的数存到指令地址码的存储单元中      |
  | 000011 | 加       | ACC中的数语存储单元的数相加，保存到ACC中 |
  | 000100 | 乘       | ACC中的数与存储单元的数相乘，保存到ACC中 |
  | 000101 | 打印     | 将指令地址码指示的存储单元操作数打印输出 |
  | 000110 | 停机     | |

  对于一个求ax2+bx+c的解题过程可以分为以下步骤

| 指令和数据存于主存单元的地址 |               指令                | 注释                         |
| :--------------------------: | :-------------------------------: | ---------------------------- |
|              0               | 操作码：000001 地址码：0000001000 | 取数x至ACC                   |
|              1               |         000100 0000001001         | 乘a得ax，存于ACC中           |
|              2               |         000011 0000001010         | 加b得ax+b，存于ACC中         |
|              3               |         000100 0000001000         | 乘x得(ax+b)x，存于ACC中      |
|              4               |         000011 0000001011         | 加c得ax2+bx+c,存于ACC中      |
|              5               |         000010 0000001100         | 存数，将ax2+bx+c存于主存单元 |
|              6               |         000101 0000001100         | 打印                         |
|              7               |              000110               | 停机                         |
|              8               |                 x                 | 原始数据x                    |
|              9               |                 a                 | 原始数据a                    |
|              10              |                 b                 | 原始数据b                    |
|              11              |                 c                 | 原始数据c                    |
|              12              |                                   | 存放数据                     |

- **存储器的基本组成**

  - 存储体–存储单元–存储元件(0/1)
  - 类似于：大楼–房间–床位(无人/有人)
  - **存储单元**：存放一串二进制1代码
  - **存储字**：存储单元中二进制代码的组合
  - **存储字长**：存储单元中二进制代码的位数

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.png)

- 主存的工作方式是按存储单元的地址号来实现对存储字各位的存、取，称为按地址存取方式

- MAR存储器地址寄存器，反映了存储单元的个数。**存放欲访问的存储单元的地址**（如MAR为10位，则有210=1024个存储单元）

- MDR存储器数据寄存器，反映存储字长。**存放从存储体某单元取出的代码或者准备往某存储单元存入的代码**

- **运算器的基本组成**

  - 最少包括3个寄存器和一个算术逻辑单元（ALU）
  - ACC为累加器
  - MQ为乘商寄存器
  - X为操作数寄存器

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E8%BF%90%E7%AE%97%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png)

  | | 加法 | 减法 | 乘法 | 除法 |
  | :--: | :--:  | :--:  | :--:  | :--:  |
  | ACC(初始就有) | 被加数及和 | 被减数及差 | 乘积高位 | 被除数及余数 |
  | MQ | | | 乘数及乘积低位 | 商 |
  | X | 加数 | 减数 | 被乘数 | 除数 |

  上表中的值为寄存器中的值

- 操作过程（[ ]代表该地址中的值，）

  - 加法：
    1. [M]->X
    2. [ACC]（被加数）+[X]（加数）->ACC
      ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM5OTc2,size_16,color_FFFFFF,t_70-20201214183533773.jpeg)
  - 减法
    1. [M]->X
    2. [ACC]（被减数）-[X]（减数）->ACC
      ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM5OTc2,size_16,color_FFFFFF,t_70-20201214183548692.jpeg)
  - 乘法
    1. [M]（乘数）->MQ
    2. [ACC]->X
    3. 0->ACC //清零
    4. [X]*[MQ]->ACC（高位）//MQ（低位）
      ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM5OTc2,size_16,color_FFFFFF,t_70-20201214183601784.jpeg)
  - 除法
    1. [M]（除数）->X
    2. [ACC]÷[X]->MQ
    3. 余数R在ACC中
  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM5OTc2,size_16,color_FFFFFF,t_70-20201214183612041.jpeg)
- **控制器**

  - 控制器的功能：
    1. **解释指令**
    
    2. 保证指令的按序执行
       
    
       ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191004214810945.png)
  - 计算机的神经中枢，指挥各部件自动、协调地工作
    1. 首先，命令存储器**读出**一条**指令**，称为取指过程（或**取指阶段**）
    2. 接着，对这条**指令**进行**分析**，指出指令完成什么操作，并按**寻址特征**指明**操作数**地址，称为分析过程（或**分析阶段**）
    3. 最后，根据操作数所在的地址以及指令的操作码完成某种操作，称为执行过程（或**执行阶段**）

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84.png)

  - PC中保存了当前要执行指令的地址，具有计数功能(PC)+1->PC，PC加几和机器的结构有关
  - IR存放当前要执行的指令，控制单元从中取出操作码
  - CU执行指令

- 取指经典过程：

  1. 取指的时候从PC开始，把要执行的指令取到IR当中
  2. 然后PC自动地把它的值指向下一个要取指的指令

- 运算器、控制器、存储器构成了什么？

  - 构成了计算机的主机

- **一条指令在主机上是如何完成的？**
  

以取数指令为例

1. **PC**把指令地址送给**MAR**
  2. 由**MAR**送给**存储体**
  3. 在控制器**CU**的控制下，**存储体**把指定存储单元中保存的取数指令取出来送去到**MDR**当中
  4. 控制器**CU**控制下，取出来的指令送入**IR**（1～4取指令）
  5. **IR**中指令的操作码部分分给**CU**
  6. **IR**中指令的地址码部分把地址取出送去**MAR**
  7. 由**MAR**送给**存储体**
  8. 在控制器的控制下，**存储体**把取数指令要取的数取出来送去到**MDR**当中
  9. 然后把数送去ACC（6～9执行指令）

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201208190705055.png)

以存数指令为例

  1. **PC**把指令地址送给**MAR**
  2. 由**MAR**送给**存储体**
  3. 在控制器**CU**的控制下，从**存储体**指定的存储单元中把这条指令取出来送去到**MDR**当中
  4. 控制器**CU**控制下，取出来的指令送入**IR**（1～4取指令）
  5. **IR**中指令的操作码部分分给**CU**，由CU对指令进行分析（分析指令）
  6. CU控制，把**IR**当中地址码部分送入**MAR**
  7. 由**MAR**送给**存储体**，告诉存储体，现在有一个数据要存进来，地址是多少
  8. 把**ACC**中的内容送入**MDR**
9. 在控制器控制下，把**MDR**中的数据存到**存储体**中（6～9执行指令）

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201208190726142.png)

- ax2+bx+c程序的运行过程

  - 将程序通过输入设备送至计算机
  - 程序首地址->PC
  - 启动程序运行
  - 取指令 PC->MAR->M->MDR->IR,（让PC+1->PC）
  - 分析指令(操作码)  OP(IR)->CU
  - 执行指令 Ad(IR)(地址部分)->MAR->M->MDR->ACC
  - 乘法指令过程······
  - ······
  - 打印结果
  - 停机

## 1.3 计算机硬件的主要技术指标
  ![Image text](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjM5OTc2,size_16,color_FFFFFF,t_70-20201214183225131.png)
### 1.3.1 机器字长

- 比如：两个8位二进制数做加法，结果是一个8位二进制，CPU一次能处理数据的位数是8位
- CPU一次能处理数据的位数，与CPU中的寄存器位数有关
- 机器字长越长，性能就越好

### 1.3.2 运算速度

- 主频
- 核数，每个核支持的线程数
- 机器的速度可以由指令执行的速度来衡量
- 吉普森法TM=∑i=1nfiti ，Tm为机器运行速度；fi为第i种指令占全部操作的百分比数，ti为第i种指令的执行时间
- **CPI**，执行一条指令所需时钟周期数（机器主频的倒数）
- **IPC**，一个时钟周期可以完成多少个指标
- **MIPS**，每秒执行百万条指令，例：200万条指令，则记**2MIPS**
- **FLOPS**，每秒浮点运算次数
- 最直接的方法：看我们最常用的软件在不同机器上的运行速度

### 1.3.3 存储容量

- 主存容量和辅存容量
- 主存容量
  - 存储容量 = 存储单元个数 * 存储字长
  
    如MAR = 10，MDR = 8即存储容量为$2^{10}*8 = 2^{13}$，1K*8位
  
    再如MAR = 16，MDR = 32即存储容量为$2^{16}*32 = 2^{21} = 2M位$，64K*32位
  - 字节数 ，如213b=1KB，221b=256KB
- 辅存容量
  
  - 80GB（1G = 1024 M = 210∗220=230）

# 第2章 计算机的发展及应用

## 2.1 计算机的发展史

- ENIAC，冯·诺依曼机器是在这个机器的研究过程中产出的
- 摩尔定律
  - 微芯片上集成的晶体管数目每三年翻两番
- 软件技术的兴起和发展
- 软件发展特点
  - 开发周期长
  - 制作成本昂贵
  - 检测软件产品质量的特殊性

## 2.2 计算机应用

- 科学计算和数据处理
- 工业控制和实时控制
- 网络技术
  - 电子商务
  - 网络教育
  - 敏捷制造
- 虚拟现实
- 办公自动化和管理信息系统
- CAD/CAM/CIMS
- 多媒体技术
- 人工智能

## 2.3 计算机的展望

- 计算机具有类似人脑的一些超级智能功能
  - 要求计算机的速度足够快
- 芯片集成度的提高受以下三方面限制
  - 芯片集成度物理极限的制约
  - 按几何级数数递增的制作成本
  - 芯片的功耗、散热、线延迟
- 替代传统的硅芯片
  - 光计算机
    - 利用光子取代电子进行运算和存储
  - DNA生物计算机
    - 通过控制DNA分子间的生化反应
  - 量子计算机
    - 利用原子所具有的量子特性

# 第3章 系统总线

## 3.1 总线的基本概念

- 什么是总线

  - 总线是连接各个部件的信息传输线，是各个部件共享的传输介质

- 总线上信息的传送

  - 串行：一位一位在总线上传送
  - 并行：多位同时，接收方也是多位
  - 串行长（多设备之间），并行短（集中在机箱内）

- 单总线结构计算机举例

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png)

  - 所有部件连接到一条总线上
  - 如果主存与I/O接口进行数据传输的话，主存和CPU之间就无法进行数据传输
  - 设备很多，系统总线会比较长

- 面向CPU的双总线结构

  - CPU和**I/O总线**相连，主存只和CPU通过**M总线**相连
  - CPU工作效率有所提高，但还是有缺点
  - 某一时刻各部件都要占用总线时，就会发生冲突（当io设备与主存通信还是会打断CPU的计算任务）

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209094121744.png)

- 以存储器为中心的双总线结构

  - 在单总线的基础上，CPU和主存都连接**系统总线**的同时再通过**存储总线**相连
  
  - 既提高了传输效率，又减轻了系统总线的负担，还保留了I/O设备与存储器交换信息时不经过CPU的特点
  
    ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209094308124.png)

## 3.2 总线的分类

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209094446406.png)

### 3.2.1 片内总线

- 芯片内部的总线
  - 比如：CPU芯片内部：
  - 寄存器与寄存器之间
  - 寄存器与算逻单元ALU之间

### 3.2.2 系统总线

- 指CPU、主存、I/O设备**各大计算机部件之间的信息传输线**

- 按传输信息不同，分为三类：数据总线、地址总线和控制总线

  1. 数据总线：**双向**传输，其位数与机器字长、存储字长有关，一般为8位、16位或32位

  2. 地址总线：**单向**传输，其位数与存储地址、I/O地址有关

  3. 控制总线：有输入，有输出

     常见的控制信号：

     - 时钟：同步各种操作
     - 复位：初始化所有部件
     - 总线请求：某部件获得总线使用权
     - 总线允许：需要获得总线使用权的部件已获得控制权
     - 中断请求：某部件提出中断请求
     - 中断响应：中断请求已被接收
     - 存储器写：将数据总线上的数据写至存储器的指定地址单元内
     - 存储器读：将指定存储单元中的数据读到数据总线上
     - I/O读：从指定的I/O端口将数据读到数据总线上
     - I/O写：将数据总线上的数据输出到指定的I/O端口内
     - 传输响应：数据已1被接收，或已将数据送至数据总线上

### 3.2.3 通信总线

- 用于**计算机系统之间**或**计算机系统与其他系统之间**的通信
- 传输方式分为两种：**串行通信**和**并行通信**

## 3.3 总线特性及性能指标

### 3.3.1 总线特性
```
当我们拆开自己使用的计算机时，都会看到很大的一块电路板。总线就是印刷在这块电路板上的，该电路板我们称为：主板、母版，然后在总线上留出接口，计算机系统的其他部件或者是模块可以通过这些接口可以连接在主板上。例如：
```
![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0.png)

1. 机械特性

   - **尺寸**、形状、**管脚数**及**排列顺序**

2. 电气特性

   - 信号的**传输方向**和有效**电平**范围

3. 功能特性

   - 每根传输线的

     功能

     - 地址总线用来指出地址码
     - 数据总线用来传递数据
     - 控制总线发出控制信号

4. 时间特性

   - 信号的**时序**关系，一般可用信号时序图来描述

### 3.3.2 总线性能指标

1. 总线宽度：**数据线**的根数，用bit表示，如8位、16位、32位、64位（即8根、16根、32根、64根）

2. 总线带宽（标准传输率）：每秒传输的最大字节数，单位MBps

   - 例：总线工作频率为33MHz，总线宽度为32位（4 B），则总线带宽位33*(32÷8)=132 MBps

3. 时钟同步/异步：同步、不同步

4. 总线复用：地址线与数据线复用

5. 信号线数：地址线、数据线和控制线的总和

6. 总线控制方式：突发、自动、仲裁、逻辑、计数

7. 其他指标：负载能力、电源电压、总线宽度能否扩展

### 3.3.3 总线标准

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86.png)

## 3.4 总线结构

### 3.4.1 单总线结构

- 导致的问题是总线成为系统的瓶颈

### 3.4.2 多总线结构

1. 双总线结构

   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209100017047.png)

   - **CPU**和**主存**及**通道**通过主存总线相连
   - I/O接口、设备通过I/O总线相连
   - I/O总线与主存总线之间通过**通道**相连
   - 通道（具有特殊功能的处理器，对I/O统一管理）有自己的指令系统，可以执行一些简单的指令
     - 通道的程序通常情况下，是由操作系统来编写的，并不是由人工来编写的

2. 三总线结构

   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209100055223.png)

   - 直接存储器访问
   - CPU是中心，如果有一些高速设备和内存之间信息交换，可以通过DMA总线与主存交换信息高速运行，但是低速设备依然要通过I/O总线

3. 三总线结构的另一种形式
   ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%BD%A2%E5%BC%8F.png)

   - CPU和主存之间交换的量最大
   - CPU运行时的指令和数据主要是从Cache中获取
   - 扩展总线解决了I/O设备的扩展问题，但影响外部设备工作速度

4. 四总线结构

   ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png)

   - 桥电路扩展出了高速总线，低速设备通过扩展总线连接到扩展总线，使数据传输速度更高

> 目前计算机都采用什么总线结构？采用哪些通信控制？
> 目前计算机多采用四总线结构：
> 局部总线：连接CPU与Cache/桥。
> 系统总线：连接Cache/桥与主存。
> 高速总线：连接Cache/桥与高速设备。
> 扩展总线：连接扩展总线接口与低速设备，其中扩展总线接口连接在高速总线上。
> 总线的通信控制包括：
> 同步通信：由统一时标控制数据传送。
> 异步通信：采用应答方式，没有公共时钟标准。
> 半同步通信：同步、异步相结合。
> 分离式通信：充分挖掘系统总线每个瞬间的潜力，特别是利用传数阶段准备数据时的总线空闲。

## 3.5 总线控制

### 3.5.1 总线判优控制 （总线调度）

- 基本概念

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191006185748480.png)

- 链式查询方式

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209101650528.png)

  - 如果有一个设备占用了总线，就通过总线忙告诉其他总线
  - 顺序是BR->BG->BR
  - 每个设备的优先级和BG有直接关系，连接方式确定的
  好比幼儿园的小朋友吃饭，坐在一张长桌上。BG线就相当于老师，从前向后的去问小朋友们谁需要加饭，直到碰到第一个需要加餐的小朋友，老师就会停下来给他加饭，他也会告诉别的小朋友，老师在给我加饭你们稍等等。
  
  > 特点：只需要很少几根线皆可以按一定优先次序实现总线控制，易扩充设备，但对电路故障很敏感。


- 计数器定时查询方式

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209101740720.png)

  - 总线控制部件里面有一个计数器，它的初值可以是0，也可以是其他值
  - 顺序是BR->接口0没有提出请求，计数器+1，看接口1有没有提出请求->通过设备地址线，项各设备发出一组地址信号，设备地址和计数器值匹配时，获得总线使用权->BS
  - 优先级可以通过设定计数器初值，循环进行
  - 设备地址线需要log2n条线

  > 特点：计数可以从0开始，设备优先次序就是固定的；也可由终点开始，即是一种循环方法；设备优先级相等；初始值也可由程序设置，故优先次序可以改变。对电路敏感不如链式，但增加了主控制线(设备地址)数，控制比较复杂。

- 独立请求方式

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209102126175.png)

  - 任何一个I/O接口都连接BR、BG
  - 总线控制部件中排队器
  - 顺序是多个BR同时发出总线请求->优先级排队
  
  > 特点：响应快，优先次序控制灵活(通过程序改变)，但控制线数量多，总线控制更复杂。
  > 工作流程：多个I/O接口部件通过BR线向总线控制部件发出请求，总线控制部件经过排队器的排队之后，对优先级高的设备授予总线的使用权。
  > 另外，链式查询仅用两根线确定总线使用权属于哪个设备，计数查询大致用 〖log〗_2⁡n 跟线，而独立请求方式需采用 2n 跟线，其中n指最大设备数。

### 3.5.2 总线通信控制(通信)

- 目的：解决通信双方**协调配合**问题

- **总线传输周期（传输过程）**

  - 申请分配阶段：**主模块申请**，总线总裁决定
  - 寻址阶段：主模块向从模块**给出地址**和**命令**
  - 传数阶段：主模块和从模块**交换数据**
  - 结束阶段：主模块撤销有关信息，让出总线使用权

- 总线通信的四种方式

  - 同步通信：由**统一时标**控制数据传送
  - 异步通信：采用**应答方式**，没有公共时钟标准
  - 半通信同步：同步、异步结合
  - 分离式通信：充分**挖掘**系统**总线每个瞬间**的潜力

- 同步式数据输入

  <img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209103059913.png" alt="在这里插入图片描述"  />

  - 在T1时钟的上升沿，必须要给出地址信号
  - 在T2上升沿必须给出读命令信号
  - 在T3上升沿到达前，从设备必须要给出数据信号，通过数据总线来传输
  - 在T3时钟周期内，将数据线上的信息送到其内部寄存器中
  - 在T4上升沿1到达前，数据信号和控制信号撤销
  - 在T4结束的时候，地址信号也撤销了

  > 它的特点是：
  >
  > - 一定要有定宽定距的时钟来控制整个数据传输的过程
  > - 要在给定的时间点上完成一些相应的操作

- 同步式数据输出

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E4%BC%A0%E8%BE%93.png)

  - 在T1上升沿给出地址信号
  - 在T1下降沿要给出数据
  - 在T2上升沿要给出写命令
  - 在T3时钟周期进行这些操作
  - 在T4上升沿，撤销数据和写命令
  - T4结束时，把地址信息也撤掉

- 同步通信优点：

  - 规定明确、统一，模块间的配合简单一致

- 同步通信缺点：

  - 主、从模块时间强制性同步
  - 必须按照最慢速度的部件来设计公共时钟

- 同步通信一般用于总线长度较短、各部件存取时间比较一致的场合

  - 因为在同步通信的总线系统中，总线的传输周期越短，数据线的位数越多，直接影响总线的数据传输率
  - 总线长度来讲,必须按距离最长的两个设备的传输延迟来设计公共时钟。但是总线长了势必降低传输频率，所以同步通信一般用于总线长度较短的场合

- 异步通信

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%BA%94%E7%AD%94%E6%96%B9%E5%BC%8F.png)

```
主设备为蓝色线（请求方），从设备为黑色线（回答方）

第一种-不互锁：主设备发出通信请求，从设备接收到通信请求以后，主设备撤销请求信号，从设备也撤销应答信号。该过程中，无论主设备是否接收到应答信号，经过一定延时之后都会撤销请求信号。从设备也不管主设备是否接收到应答信号，经过延迟都会撤销应答信号


第二种-半互锁：主设备发出请求，从设备接收到请求之后发出应答信号，主设备接收到应答信号之后，才会撤销请求信号。该过程中，若主设备没有接收到从设备的应答信号，则会一直保持发出请求信号。从设备发出应答信号之后，不管对方是否接收到应答信号，经过一段时间延迟后，都会撤销应答信号。这样会造成请求信号一直保持高电平


第三种-全互锁：主设备发出请求，从设备接收到请求之后发出应答信号后，主设备接收到应答信号之后，才会撤销请求信号。该过程中，只有主设备撤销了请求信号之后，从设备才会撤销应答信号。该方式可以完成最可靠的数据传输
```

- 半同步通信（同步、异步结合）

  - 同步：

    - **发送方**用系统**时钟前沿**发信息
    - **接收方**用系统**时钟后沿**判断、识别

  - 异步

    - 允许不同速度的模块和谐工作
    - 为了调整主从设备差异速度的差异，增加了一条“等待”响应信号**WAIT**

  - 以输入数据为例的半同步通信时序

    ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png)
    - T1周期上沿  主模块发出地址

    - T2周期上沿  主模块发出命令 - 读信号
    ```
         如果主模块与从模块之间速度不不一致，例如：CPU 与 存储器，CPU的工作速度要比存储器高，在T3时钟到来之前，从模块无法向主模块提供数据， 这时从模块就要发出WAIT信号，主模块检测WAIT信号线，如果是低电平就会插入一个TW时钟周期等待数据的到来。这时才可以进入T3周期。
    ```
    - T3周期上沿  从模块提供数据，将数据放在数据总线上，主模块开始在数据总线上接收数据

    - T4周期上沿  从模块撤销数据，主模块撤销命令

- 以上三种通信的共同点

  - 一个总线传输周期（以输入数据为例）
    - 从模块发地址、命令 **占用总线**
    - 从模块准备数据 **不占用总线**
    - 从模块向主模块发数据 **占用总线**

- 分离式通信

  - 充分挖掘系统总线每个瞬间的潜力
  - 一个总线传输周期（**让出了准备数据的时间**，**让总线干别的事**）
    - 子周期1:主模块申请占用总线，使用完后即放弃总线的使用权
    - 子周期2:从设备申请占用总线，将各种信息送至总线上
  - 特点：
    1. 各模块都有权申请占用总线
    2. 采用同步通信，不等对方回答
    3. 各模块准备数据时，不占用总线
    4. 总线被占用时，无空闲

# 第4章 存储器

## 4.1 概述

### 4.1.1 存储器分类

- 按存储介质分类（半导体，磁，光）

  1. (1) 半导体存储器  TTL 、 MOS               易失
     (2) 磁表面存储器  磁头、载磁体            \
     (3) 磁芯存储器    硬磁材料、环状元件      非易失
     (4) 光盘存储器    激光、磁光材料         /

- 按存取方式分类

  1. 随机存储器（在程序的执行过程中 可 读 可 写）
  2. 只读存储器（在程序的执行过程中 只 读）
  3. 串行访问存储器
     1. 顺序存取存储器（磁带）
     2. 直接存取存储器（磁盘）

- 按在计算机中的作用分类

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E5%AD%98%E5%82%A8%E5%99%A8%E6%8C%89%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB.png)



### 4.1.2 存储器的层次结构

- 存储器3个主要性能指标：速度、容量、位价

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209110700477.png)

- 层次结构主要体现在缓存-主存和主存-辅存这两个存储层次上

  ![image-20201209111634331](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/image-20201209111634331.png)

  - 缓存-主存层次解决CPU和主存速度不匹配，使速度接近缓存，高于主存
  - 主存-辅存层次解决存储系统的容量问题（虚拟内存 -操作系统）

## *4.2 主存储器

### 4.2.1 概述

- 主存的基本组成

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209111934195.png)

- 主存和CPU的联系

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E7%9A%84%E8%81%94%E7%B3%BB.png)

  备注：MDR、MAR在CPU中

- 主存中存储单元地址的分配

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209112307419.png)

  - 大端、小端方式
  - 设地址线24根，按**字节**寻址$2^{24}$=16MB
  - 若字长为16位，按字寻址8M字
  - 若字长为32位，按字寻址4M字

- 主存的技术指标

  - 存储容量：主存、存放二进制代码的总位数
  - 存储速度：
    - 存取时间：存储器的访问时间（读出时间、写入时间）
    - 存取周期：连续两次独立的存储器操作（读或写）所需的最小间隔时间（读周期、写周期），存取周期＞存取时间
  - 存储器的带宽：位/秒

### 4.2.2 半导体存储芯片简介

- 基本结构
  
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209113349590.png)
  
  - 地址线单向输入，数据线双向
    - 例如：地址线10根，数据线4根，则芯片容量=$2^{10}$∗4=4K
    - 又例如：地址线14根，数据线1根，则容量为16K
  - 存储芯片片选线的作用
    ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-7941967.png)
  
- 线选法：一根字选择线，直接选中一个存储单元的各位(16*1字节:1片)

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209113931533.png)

- 重合法：所选单元由X、Y（行列地址）两个方向决定 (1K *1位:8片芯片)

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209113942007.png)

### 4.2.3 随机存取存储器（RAM）

- 静态RAM(SRAM)
  **静态 RAM 芯片举例**
  Intel 2114 外特性
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209114516324.png)② Intel 2114 RAM 矩阵 (64 × 64) 读
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209114516599.png)

   Intel 2114 RAM 矩阵 (64 × 64) 写
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201214183252270.png)

- 动态RAM(DRAM)
  
  ①三管动态 RAM 芯片 (Intel 1103) 读
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201214183317815.png)② 三管动态 RAM 芯片 (Intel 1103) 写
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201214183324791.png)
  
  - 电容上保存的有电荷1，无电荷0
  - 动态RAM刷新
    - 与行地址有关，与列地址无关，每次刷新都刷新一行的数据
    - 有些存储单元长期得不到访问，不进行存储器的读/写操作，存储单元内的原信息将会慢慢消失，为此，必须采用定时刷新的方法
    - 集中刷新（存取周期为0.5µs）：规定一个刷新周期，此周期内停止读/写操作，这个周期又称访存死区
    - 分散刷新：每行存储单元的刷新分散到每个存取周期内完成
    - 异步刷新（结合分散刷新与集中刷新）：将刷新安排在指令译码阶段，不会出现”死区“
  
- 动态和静态比较

  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209150239243.png)

### 4.2.4 只读存储器（ROM）

- 掩模ROM（MROM）
  - 行列选择线交叉处有MOS管为“1”，无为“0”
- PROM（一次性编程）
  - 熔丝断为“0”，未断为“1”
  - 是一种破坏性编程
- EPROM（多次性编程）
  - N型沟道浮动栅MOS电路
    - D端加正电压，形成浮动栅，S和D不导通
    - D端不加正电压，S与D导通为“1”
  - 改写方法：紫外线照射
  - 价格便宜1，集成度高
- EEPROM（多次性编程）
  - 电可擦写：可局部擦写也可全部擦写
- Flash Memory（闪速型存储器）
  - 比EEPROM快，具备RAM功能

### *4.2.5 存储器与CPU的连接

1. **存储器容量的扩展**

   1. 位扩展（增加存储字长）

      用2片 1Kx4位 存储芯片组成 1Kx8位 的存储器

      - 地址线连接方式完全相同
      - 数据线各占了按序的4位

   2. 字扩展（增加存储字的数量）

      用2片 1Kx8位 存储芯片组成 2Kx8位 的存储器

      - 数据线连接相同
      - 地址线一条用作片选信号，选择通过电平高低进行选择

   3. 字、位扩展

      用8片 1Kx4位 的芯片组成 4Kx8位 的存储器

      - 两个一组先构成8位的存储字长
      - 分为4组，通过两根地址线经过译码器得到4个片选信号
      
      ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151003017.png)

2. **存储器与CPU的连接**

   1. 地址线的连接
   2. 数据线的连接
   3. 读写命令线的连接
   4. 片选线的连接
   5. 合理选择存储芯片
   6. 其他：时序、负载

> **例4.1** 设CPU有**16根地址线**,8根数据线，并用 (MREQ) ̅ 作为访存控制信号(低电平有效),用用 (WR) ̅ 作为读/写控制信号(高电平为读,低电平为写)。现有下列存储芯片:1K*4位RAM,4K*8位RAM,8K*8位RAM,2K*8位ROM,4K*8ROM,8 K*8位ROM及74138译码器和各种门电路,如图所示。画出CPU与存储器的连接图,要求如下:
> ①主存地址空间分配：
> 6000H~67FFH为系统程序区。
> 6800H~6BFFH为用户程序区。
> ②合理选用上述存储芯片，说明各选几片。
> ③详细画出存储芯片的片选逻辑图。
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043583.png)
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043965.png)
> (3) 分配地址线
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043771.png)
> (4) 确定片选信号
> ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043857.png)
> 备注：MREQ存储器请求，确定本次访问时存储器(低电平)还是I/O(高电平)。(WR) ̅ 代表低电平为写，高电平为读。连接连个RAM的时候还得保证A10为低电平才行。

### 4.2.6 存储器的校验

- 为什么要对存储器的信息进行校验？
- 为了能够校验出信息是否正确，如何进行编码？
- 纠错或检错能力与什么因素有关？
- 校验出信息出错后是如何进行纠错？
- 除了我们教材上讲的校验码，你还知道哪些容错编码？，原理是什么？
  
- 合法代码集合
  ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044402.png)

1. 编码的最小距离
   任意两组合法代码之间二进制位数的最少差异
   编码的纠错、检错能力与编码的最小距离有关
   L − 1 = D + C ( D ≥ C ) 
   *L* —— 编码的最小距离 L = 3 
   *D* —— 检测错误的位数
   *C* —— 纠正错误的位数
   汉明码是具有一位纠错能力的编码

2. 汉明码的组成
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044222-7497844.png)
   **组成汉明码的三要素**
   汉明码的组成需增添 ？

   *k*位检测位 $2^k$ ≥ n + k + 1,*n*为代码长度
   检测位的位置 ？ 

   $2^i$ ( i = 0 ， 1 ， 2 ， 3 ， … i = 0， 1， 2 ， 3 ， …*i*=0，1，2，3，… )
   检测位的取值 ？

   与该位所在的检测“小组” 中承担的奇偶校验任务有关
    
   **各检测位 C i C_i\*C\**i\*​ 所承担的检测小组为**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151043830.png)

3. 汉明码的纠错过程

![image-20201209160139222](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/image-20201209160139222.png)

![image-20201209160348125](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/image-20201209160348125.png)

**不出错时 P1 = 0 ， P2 = 0 ， P4 = 0** 

### 4.2.7 提高访存速度的措施

- 采用高速器件
- 采用层次结构 Cache –主存
- 调整主存结构

1. 单体多字系统
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013121517436.png)
2. 多体并行系统
   (1) 高位交叉 顺序编址 各个体并行工作
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044080.png)
   
   (2) 低位交叉 各个体轮流编址
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044290.png)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209151044336.png)
   **低位交叉的特点**
   在不改变存取周期的前提下，增加存储器的带宽
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70.png)
   设四体低位交叉存储器，存取周期为T，总线传输周期为τ，为实现流水线方式存取，应满足 T ＝ 4τ。
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201209151044440.png)
   连续读取 4 个字所需的时间为T＋(4 －1)τ
3. 高性能存储芯片
   **(1) SDRAM (同步 DRAM)**
   在系统时钟的控制下进行读出和写入
   CPU 无须等待
   **(2) RDRAM**
   由 Rambus开发，主要解决存储器带宽问题
   **(3) 带 Cache 的 DRAM**
   在DRAM的芯片内集成了一个由 SRAM 组成的Cache，有利于猝发式读取

## 4.3、高速缓冲存储器

### 4.3.1 概述

1. 问题的提出
   避免 CPU “空等” 现象
    
   CPU 和主存（DRAM） 的速度差异
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013114601398.png)
2. Cache的工作原理
   **(1) 主存和缓存的编址**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160712681.png)
   主存和缓存按块存储块的大小相同B为块长
    
   **(2) 命中与未命中**
   缓存共有C 块，主存共有M 块 M >> C
   **命中**：主存块调入缓存，主存块与缓存块建立了对应关系
   用标记记录与某缓存块建立了对应关系的主存块号
   **未命中**：主存块未调入缓存
   主存块与缓存块未建立对应关系
    
   **(3) Cache 的命中率**
   CPU 欲访问的信息在Cache 中的比率
   命中率与Cache 的容量与块长有关
   一般每块可取 4 ~ 8 个字
   块长取一个存取周期内从主存调出的信息长度
   CRAY_1：16体交叉，块长取 16 个存储字
   IBM 370/168：4体交叉，块长取 4 个存储字(64位× 4 = 256位)
    
   **(4) Cache–主存系统的效率**
   效率 e 与 命中率 有关
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013115025612.png)
   设 Cache 命中率 为 h， 访问 Cache 的时间为 tc，访问 主存 的时间为 tm，则
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013115046542.png)
3. Cache 的基本结构
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713000.png)
4. Cache的读写操作 -读
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713002.png)
   **写 - Cache 和主存的一致性**
   • **写直达法**（Write–through）
   写操作时数据既写入Cache又写入主存
   写操作时间就是访问主存的时间， Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现
   • **写回法**（Write–back）
   写操作时只把数据写入 Cache 而不写入主存
   当 Cache 数据被替换出去时(原数据)才写回主存
   写操作时间就是访问 Cache 的时间，
   Cache块退出时，被替换的块需写回主存，增加了Cache的复杂性
5. Cache 的改进
   **(1) 增加 Cache 的级数**
   • 片载（片内）Cache 单一缓存
   • 片外Cache 两级缓存
   **(2) 统一缓存和分立缓存**
   • 指令Cache 数据Cache
   • 与指令执行的控制方式有关 是否流水

### 4.3.2 Cache–主存的地址映射

1. 直接映射
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713572.png)
   每个缓存块 *i* 可以和若干个主存块对应
   每个主存块 *j* 只能和一个缓存块对应
2. 全相联映射
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713496.png)
   主存中的任一块可以映射到缓存中的任一块
3. 组相联映射
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713848.png)
   **直接**：某一主存块只能固定映射到某一缓存块（靠近CPU）
   **全相联**：某一主存块能映射到任一缓存块（距离CPU最远）
   **组相联**：某一主存块只能映射到某一缓存组中的任一块（与CPU距离中等）

### 4.3.3 替换算法
```
# 先进先出（FIFO）算法
选择最早调入Cache的字块进行替换，不需要记录各字块的使用情况，比较容易实现，但是不能提高Cache的命中率，因为没有利用访存的局部性原理
 
# 近期最少使用（Least Recently Used, LRU）算法
比较好的利用了局部性原理，替换出近期使用最少的字块，需要随时记录Cache中各字块的使用情况，以便确定哪个字块是近期最少使用的字块，平均命中率比FIFO高
 
# 随机法
随机确定被替换的块，比较简单，也不能提高命中率
```

### 4.3.4 cache与TLB快表的区别
 - 工作流程
 快表是单独的寄存器，页表是存在于主存。TLB又称页表缓存，为了加速页表查询的。根据执行步骤：当CPU执行机构收到应用程序发来的虚拟地址后，首先到TLB中查找相应的页表数据，如果TLB中正好存放着所需的页表，则称为TLB命中（TLB Hit）,接下来CPU再依次看TLB中页表所对应的物理内存地址中的数据是不是已经在一级、二级缓存里了，若没有则到内存中取相应地址所存放的数据。可以看出TLB是单独的寄存器。
 - cache
 当CPU处理数据时，它会先到Cache中去寻找，如果数据因之前的操作已经读取而被暂存其中，就不需要再从随机存取存储器（Main memory）中读取数据——由于CPU的运行速度一般比主内存的读取速度快，主存储器周期（访问主存储器所需要的时间）为数个时钟周期。因此若要访问主内存的话，就必须等待数个CPU周期从而造成浪费。
 
 提供“缓存”的目的是为了让数据访问的速度适应CPU的处理速度，其基于的原理是内存中“程序执行与数据访问的局域性行为”，即一定程序执行时间和空间内，被访问的代码集中于一部分。为了充分发挥缓存的作用，不仅依靠“暂存刚刚访问过的数据”，还要使用硬件实现的指令预测与数据预取技术——尽可能把将要使用的数据预先从内存中取到缓存里。
 
 - TLB
    TLB 用于缓存一部分标签页表条目。TLB可介于 CPU 和CPU缓存之间，或在 CPU 缓存和主存之间，这取决于缓存使用的是物理寻址或是虚拟寻址。如果缓存是虚拟定址，定址请求将会直接从 CPU 发送给缓存，然后从缓存访问所需的 TLB 条目。如果缓存使用物理定址，CPU 会先对每一个存储器操作进行 TLB 查寻，并且将获取的物理地址发送给缓存。两种方法各有优缺点。

## 4.4、辅助存储器

### 4.4.1 概述

1. 特点 不直接与 CPU 交换信息
2. 磁表面存储器的技术指标
   (1) 记录密度 道密度 Dt 位密度 Db
   (2) 存储容量 C = n × k × s
   (3) 平均寻址时间 寻道时间 + 等待时间
   辅存的速度 寻址时间&磁头读写时间
   (4) 数据传输率 Dr = Db × V
   (5) 误码率 出错信息位数与读出信息的总位数之比

### 4.4.2磁记录原理和记录方式

1. 磁记录原理 (读和写)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013121832221.png)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713720.png)

### 4.4.3 硬磁盘存储器

1. 硬磁盘存储器的类型
   (1) 固定磁头和移动磁头
   (2) 可换盘和固定盘
2. 硬磁盘存储器结构
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013115844349.png)
   **(1) 磁盘驱动器**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160713911.png)
   **(2) 磁盘控制器**
   • 接收主机发来的命令，转换成磁盘驱动器的控制命
   • 实现主机和驱动器之间的数据格式转换
   • 控制磁盘驱动器读写
   磁盘控制器 是主机与磁盘驱动器之间的 接口
    
   **(3) 盘片 由硬质铝合金材料制成**

### 4.4.4 软磁盘存储器

1. 概述
   ![2.](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191013122245826.png)
2. 软盘片——由聚酯薄膜制成
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201209160714434.png)

### 4.4.5 光盘存储器

1. 概述
   采用光存储技术——利用激光写入和读出
   第一代光存储技术——采用非磁性介质 不可擦写
   第二代光存储技术——采用磁性介质 可擦写
2. 光盘的存储原理
   只读型和只写一次型——热作用（物理或化学变化）
   可擦写光盘——热磁效应



# 第五章 I/O系统

### 5.1.1 I/O 系统的发展概况

1. 早期
   分散连接
   CPU和I/O设备串行工作 程序查询方式
2. 接口模块和 DMA 阶段
   总线连接
   CPU和I/O设备并行工作（中断方式、DMA方式）
3. 具有通道结构的阶段
   通道负责管理I/O设备以实现主存与I/O设备之间交换信息的部件，是一个从属于CPU且不完全独立的处理器。
4. 具有I/O处理机的阶段

### 5.1.1 I/O 系统的组成
```
#I/O软件
将用户编制的程序（或数据）输入至主机内，将运算结果输送给用户；
采用接口模块方式时，机器指令系统的I/O指令+系统软件中的管理程序；
采用通道管理方式时，I/O指令+通道指令+操作系统；
 
#I/O硬件
接口系统，包括接口模块+I/O设备两大部分
通道或I/O处理机系统，包括通道（或I/O处理机）+设备控制器+ I/O设备
```

### 5.1.2 I/O 设备与主机的联系方式

1. I/O设备编址方式
   (1)统一编址  看作存储器的一部分(占用主存)，用取数、存数指令
   (2)不统一编址  有专门的I/O指令
2. 设备选址
   用设备选择电路识别是否被选中
3. 传送方式
   (1)串行  速度慢，但只需一根数据线，适合远距离数据通信
   (2)并行  速度快，数据线多
4. 联络方式
   (1) 立即响应 指示灯等
   (2) 异步工作采用应答信号 见下图(分并行和串行)
   (3) 同步工作采用同步时标 I/O设备与CPU工作速度完全同步
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105142811497.png)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105142816519.png)
5. I/O 设备与主机的连接方式
   (1) 辐射式连接
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105142839628.png)
   (2) 总线连接
   便于增删设备，现代计算机基本采用

### 5.1.3 I/O 设备与主机信息传送的控制方式 （在接口电路中实现）

1. 程序查询方式
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201210184614246.png)
   
2. 程序中断方式
   I/O 工作  自身准备阶段        CPU不查询
           与主机交换信息阶段   CPU暂停现行程序
   CPU和 I/O 部分的并行工作
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105143315322.png)
   程序中断方式流程
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_1,color_FFFFFF,t_70-20201210184614184.png)
   
   在中断请求之后还要保护现场，等io传输完成之后，还要恢复现场，这些都还是会**占据CPU的**，会消耗一部分时间。而且读入时还需要**CPU做为中转站**，才能将数据读到内存。
   
3. DMA方式
   主存和I/O之间有一条直接数据通道
   不中断现行程序
   周期挪用（周期窃取） CPU和I/O并行工作，**在存取周期时CPU不能占据总线，但是CPU是可以执行其他指令（因为CPU不能访问内存，所以这些指令是CPU缓存中的）的，等一个存取周期结束，将总线的使用权再还给CPU。**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105143433537.png)

4. 三种方式的CPU工作效率比较
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105143454770.png)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105143606418.png)
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/201911051436105.png)

```
# 从数据传送看，程序中断方式靠程序传送，DMA方式靠硬件传送
 
# 从CPU响应时间看，程序中断方式是在一条指令执行结束时响应，DMA方式在指令内任一存取周期结束时响应
 
# 程序中断方式有处理异常事件的能力，DMA没有
 
# 程序中断需要中断现行程序，故需要保护现场；DMA不需要保护现场
 
# DMA优先级比程序中断优先级更高
```





## 5.2 外部设备

### 5.2.1 概述

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105143648374.png)
外部设备大致分三类
1.人机交互设备 键盘、鼠标、打印机、显示器
2.计算机信息存储设备 磁盘、光盘、磁带
3.机-机通信设备 调制解调器等

### 5.2.2 输入设备

1. 键盘
   按键 → 判断哪个键按下 → 将此键翻译成ASCII码（编码键盘法）
2. 鼠标
   机械式  金属球 电位器
   光电式  光电转换器
3. 触摸屏

### 5.2.3 输出设备

1. 显示器
   (1)字符显示  字符发生器
   (2)图形显示  主观图像
   (3)图像显示  客观图像
2. 打印机
   (1)击打式    点阵式（逐字、逐行）
   (2)非击打式   激光（逐页）喷墨（逐字）

### 5.2.4 其他

1. A/D、D/A
   模拟/数字（数字/模拟）转换器
2. 终端
   由键盘和显示器组成
   完成显示控制与存储、键盘管理及通信控制
3. 汉字处理
   汉字输入、汉字存储、汉字输出

### 5.2.5 媒体技术

1. 什么是多媒体
2. 多媒体计算机的关键技术

## 5.3 接口

### 5.3.1 概述

为什么要设置接口？

1.一台机器通常配有多台I/O设备，通过接口可以实现I/O设备的选择

2.I/O设备的速度不一，与CPU可能相差很大，通过接口可以实现数据缓冲达到数据匹配

3.有些I/O设备可能串行传输数据而CPU一般为并行传送，通过接口可以实现串/并格式的转换

4.I/O设备的输入输出电平可能与CPU的输入输出电平不同，通过接口可实现电平转换

5.CPU启动I/O设备工作，通过接口可以传送控制命令

6.I/O设备需要将其工作状态**（“忙”，“就绪”，“错误”，“中断请求”等）**及时向CPU报告，通过接口可以监视设备的工作状态，共CPU查询


### 5.3.2 接口的功能和组成

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614327.png)

1. 总线连接方式的I/O接口电路
   (1) 设备选择线
   (2) 数据线
   (3) 命令线
   (4) 状态线
2. 接口(通用)的功能和组成

| 功能                               | 组成                 |
| ---------------------------------- | -------------------- |
| 选址                               | 设备选择电路         |
| 传送命令（控制设备是输入还是输出） | 命令寄存器命令译码器 |
| 传送数据                           | 数据缓冲寄存器       |
| 反映设备状态                       | 设备状态标记         |

完成触发器 D
工作触发器 B
中断请求触发器 INTR
屏蔽触发器 MASK
(如：D=0,B=0设备暂停状态、D=1,B=0设备准备就绪、D=1,B=1设备准备状态、INTR=1I/O设备向CPU发出中断请求)

1. I/O接口的基本组成
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614439.png)

### 5.3.3 接口类型

1. **按数据传送方式分类**
   并行接口   Intel 8255
   串行接口   Intel 8251
2. **按功能选择的灵活性分类**
   可编程接口     Intel 8255、 Intel 8251
   不可编程接口   Intel 8212
3. **按通用性分类**
   通用接口   Intel 8255、 Intel 8251
   专用接口   Intel 8279、 Intel 8275
4. **按数据传送的控制方式分类**
   中断接口    Intel 8259
   DMA 接口   Intel 8257

## 5.4 程序查询方式

### 5.4.1 程序查询流程

1. 查询流程
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614437.png)
2. 程序流程
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614434.png)

### 5.4.2 程序查询方式的接口电路

以输入为例，在第五步之前CPU一直在原地踏步。
![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614516.png)

### 5.5 程序中断方式

### 5.5.1 中断的概念

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614495.png)

### 5.5.2 I/O 中断的产生

以打印机为例 CPU与打印机部分并行工作
![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614655.png)

### 5.5.3 程序中断方式的接口电路

1. **配置中断请求触发器和中断屏蔽触发器**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614656.png)
   注意：设备发出中断请求时，其本身必须准备就绪，即D=1
   中断源：把凡能向CPU提出中断请求的各种因素称为中断源
2. **排队器**
   排队 硬件方法  在CPU内设一统一排队器或在接口电路中(链式排队器)
        软件方法  详见第八章
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614679.png)
   设备1#、2#、3#、4# 优先级按 降序排列
   **3.中断向量地址形成部件**
   入口地址   由软件产生   详见第八章
             硬件向量法   由硬件产生 向量地址，再由向量地址找到入口地址
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614713.png)
   
   4.**程序中断方式接口电路的基本组成**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614769.png)

### 5.5.4 I/O 中断处理过程

1. **CPU响应中断的条件和时间**
   **(1)条件**
   允许中断触发器 EINT = 1
   用开中断指令将 EINT 置“1”
   用关中断指令将 EINT 置“0”或硬件自动复位
   **(2)时间**
   当D=1（随机）且MASK=0 时
   在每条指令执行阶段的结束前
   CPU 发中断查询信号（将 INTR 置“1” ）
2. **I/O中断处理过程**
   以输入为例
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614790.png)
   中断处理过程简化为：中断请求、中断判优、中断响应、中断服务、中断返回

### 5.5.5 中断服务程序流程

1. **中断服务程序的流程**
   **(1) 保护现场**
   程序断点的保护  中断隐指令完成
   寄存器内容的保护  中断服务程序令完成 存储器保存或进栈指令
   **(2)** **中断服务** 对不同的 I/O 设备具有不同内容的设备服务
   **(3)** **恢复现场** 出栈指令
   **(4)** **中断返回** 中断返回指令
2. **单重中断和多重中断**
   单重中断  不允许中断现行的中断服务程序
   多重中断  允许级别更高的中断源中断现行的中断服务程序
3. **单重中断和多重中断的服务程序流程**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614880.png)
4. **主程序和服务程序抢占CPU示意图**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614815.png)
   宏观上 CPU 和 I/O 并行工作
   微观上 CPU 中断现行程序为 I/O 服务

## 5.6 DMA方式

### 5.6.1 DMA方式的特点

1. DMA程序中断两种方式的数据通路（io设备到内存不用经过cpu）
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614823.png)
2. DMA与主存交换数据的三种方式
   （1）停止CPU访问主存
        控制简单
        CPU 处于不工作状态或保持状态
        未充分发挥CPU对主存的利用率（传输间隔可能会很长）
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105151815855.png)
   （2）周期挪用（或访存周期窃取）
         CPU此时不访存
        CPU正在访存
        CPU与DMA 同时请求访存
        此时 CPU 将总线控制权让给 DMA
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105151840664.png)
   （3）DMA与CPU交替访问
        CPU工作周期 C1专供DMA 访存
                     C2专供CPU 访存
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105151849466.png)
   不需要申请建立和归还总线的使用权

### 5.6.2 DMA接口的功能和组成

1. DMA接口功能
   (1)向CPU申请 DMA 传送
   (2)处理总线控制权的转交
   (3)管理系统总线、控制数据传送
   (4)确定数据传送的首地址和长度，修正传送过程中的数据地址和长度
   (5)DMA传送结束时，给出操作完成信号
2. DMA接口组成
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614922.png)
```
# 主存地址寄存器（AR）
存放主存中需要交换数据的地址，交换数据前需要把主存中首地址送到AR，交换数据中每交换一次数据将地址寄存器内容加1直到第一批数据传送完毕
 
# 字计数器（WC）
记录传送数据的总字数，每次+1或-1直至计数器为0
 
# 数据缓冲寄存器（BR）
BR用于暂存每次传送的数据
 
# DMA控制逻辑
负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成
 
# 中断机构
当字计数器(WC)溢出（全“0”）时，表示一批数据交换完毕，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作DMA操作的后处理；这里与I/O系统中的中断事件有一定区别
 
# 设备地址寄存器(DAR）
DAR存放I/O设备的设备码或表示设备信息存储区的寻址信息，如磁盘数据所在的区号、盘面号和柱面号。

DREQ- DMA请求信号，HRQ-总线使用权请求信号
HLDA-CPU响应信号，DACK- 授予一个DMA周期
```


### 5.6.3 DMA的工作过程

1. **DMA传送过程**
```
# 预处理
指明数据传送方向（输入还是输出）；
DMA设备地址寄存器送入设备号，启动设备：设备地址→DMA的DAR
DMA主存地址寄存器送入交换数据的主存起始地址：主存地址→DMA的AR
DMA计数寄存器送入传送字数：传送字数→DMA的WC
# 数据传送
DMA以数据块为单位传送，流程如下
1.当准备好一个字时，发出选通信号，将该字读到DMA的数据缓冲寄存器（BR）中，表示数据缓冲寄存器“满”；
2.设备向DMA接口发出请求（DREQ）
3.DMA接口向CPU申请总线控制权（HRQ）
4.CPU发回HLDA信号，表示允许将总线控制权交给DMA接口
5.将DMA主存地址寄存器中的主存地址送地址总线，并命令存储器写
6.通知设备已被授予一个DMA周期（DACK），并为下一个字做准备
7.将DMA数据缓冲寄存器的内容送数据总线
8.主存将数据总线上的信息写至地址总线指定的存储单元中
9.修改主存地址和字计数值
10.判断数据块是否传送结束，若未结束则继续传送；若已结束，则向CPU申请程序中断，标志数据块传送结束；
 
# 后处理
包括检验送入主存的数据是否正确；决定是否使用DMA继续传送其他数据块；测试在传送过程中是否发生错误错则转诊断程序，由中断服务程序完成
```
   **DMA传送过程示意**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184615010.png)
   **数据传送过程（输入）**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614970.png)
   **数据传送过程（输出）**
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184614950.png)

   **后处理**
   校验送入主存的数是否正确
   是否继续用DMA
   测试传送过程是否正确，错则转诊断程序
   由中断服务程序完成

2. **DMA接口与系统的连接方式**
   **(1) 具有公共请求线的DMA请求**（越靠近CPU优先级越高）
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/20191105152355169.png)
   **(2) 独立的DMA请求**

   ![image-20201212170539705](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/image-20201212170539705.png)






3. DMA方式与程序中断方式的比较

|              | 中断方式     | DMA方式      |
| ------------ | ------------ | ------------ |
| 数据传送     | 程序         | 硬件         |
| 响应时间     | 指令执行结束 | 存取周期结束 |
| 处理异常情况 | 能           | 不能         |
| 中断请求     | 传送数据     | 后处理       |
| 优先级       | 低           | 高           |

### 5.6.4 DMA接口的类型

1. 选择型 在物理上连接多个设备
          在逻辑上只允许连接一个设备
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-7941860.png)
2. 多路型 在物理上连接多个设备
           在逻辑上允许连接多个设备同时工作
3. 多路型DMA接口的工作原理
   ![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%93%88%E5%B7%A5%E5%A4%A7%EF%BC%89.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTA1NzA1,size_16,color_FFFFFF,t_70-20201210184615098.png)
